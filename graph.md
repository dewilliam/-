<h2>16年5月19，周四</h2>
用邻接表保存图信息。<br>
在磁盘中用一下形式保存：<br>
1 beijing 3 2 30 3 60 5 100<br>
2 tianjin 2 1 30 4 200<br>
3 tangshan 1 1 60<br>
4 nanjing 1 2 200<br>
5 jinan 1 1 100<br>
每列开头为顶点编号，顶点名称。<br>
之后:第一个为与该顶点相邻的顶点个数，后面是每个相邻顶点的编号，和边的权值。<br>
<br>
在内存中保存形式为：<br>
用pair<int,int>保存相邻的顶点和权值。<br>
每一个顶点的所有pair都放在一个vector里面。<br>
定义一个Node类，保存顶点信息（顶点编号，顶点名称，指向对应vector的指针）。<br>
Node --> vector(pair(int,int),pair(int,int),...)。<br>
<br>
dijkstra算法时，从源顶点开始，遍历它的邻接表中的顶点，更新每个顶点的distance值，找到最小的那个，重复执行<br>
每执行一次上述逻辑，list_num计数器减一，直到list_num==0为止<br>
<br>
不知道对不对，，，晚上试一下<br>

<h3>22:52</h3>
上述方法可以实现，但要在每个节点上在加一个属性marked，某个节点做过最小距离的节点后，marked置为true，以后就不再处理该节点<br>
源代码放在dijkstra.cpp中<br>
<br>
<h2>16年5月20</h2>
今天520，还在写代码。。。~>_<~<br>
<h3>8:58</h3>
把dijkstra.cpp中加了点注释<br>
下一步把Fibonacci heap 加到该算法中。<br>
加的位置为寻找在S集合中寻找路径最小的顶点过程。<br>
但是我现在觉得，在“松弛”过程中寻找最小距离顶点已经够省时间的了，反正“松弛”也要循环处理邻接表，不在乎多比较一次最小值吧<br>
再看看。。。<br>
另外，dijkstra算法不能处理有负权值的边的图。因为：<br>
若负权值出现在已经处理过的（marked=true）的临界表中的节点对该节点的边上，则不会处理到这个负值信息。<br>
如果要改进，则去掉marked成员，但是这样肯定会出现循环<br>
<h2>16年5月22</h2>
<h3>下午3:55</h3>
重看了一遍《心花路放》，黄渤的演技就是屌。。。<br>
整理下心情，开始写代码<br>
看了一下网络流问题。增广路方法和预流推进重标号方法。<br>
SAP(shortest-Augmenting-Path)：E-K，Dinic算法等实现方式。<br>
E-K算法在每次找增广路时都执行一次BFS搜索，这样显然时间复杂度太高，有很多步骤冗余。<br>
so，着重看一下Dinic算法<br>
Dinic算法步骤：<br>
1.用BFS建立分层图  注意:分层图是以当前图为基础建立的,所以要重复建立分层图<br>
2.用DFS的方法在分层图中寻找一条由源点到汇点的路径,获得这条路径的流量X<br>
在这一步中，“这条路径的流量X”是指在这条增广路中最小流量的边拥有的流量。<br>
3.根据这条路径修改整个图,将所经之处正向边流量减少X,反向边流量增加X,注意X是非负数<br>
4.重复步骤2,直到DFS找不到新的路径时,重复步骤1<br>
重复进行BFS就是对反向弧的应用，在生成反向弧之后，层次可能会出现变化。。。<br><br>
这个博客不错<a href="https://comzyh.com/blog/archives/568/">网络流入门—用于最大流的Dinic算法</a><br>
反向弧是一定要加的，而且随着更广路的改变，反向弧中的剩余流量也要跟着增加。<br>
因为，如果不增加或改变反向弧的话，相当与砍掉了其他流过该节点的流量继续向下走的机会。<br>
要知道，整个图的流量是同时走的，而，算法的执行是一条路径一条路径的计算，<br>这样的模型，就会造成本来是同时有不同的路径同时走的不同的流量产生截断，不能在继续走了。<br>所以一定要有反向弧！！<br>
<h3>下午5:13</h3>
刚刚跟前女友聊天，真他妈不爽，结合一下心花路放，我他妈又没心情写代码了，，，，<br>
前任是个可怕的动物，没有之一啊，，，，<br>
<h3>下午7:35</h3>
继续写代码。。<br>
设置了一个存放图的磁盘文件dinic_data<br>
第一行存放顶点的个数，边的个数<br>
下面没一行都存放着一个边信息：尾顶点，头顶点，边的权值。<br>
这样在内存中既可以以邻接矩阵的形式存放，也可以用邻接表存放。<br>
终于写出来了dinic算法，放在了graph_dinic.cpp中。。<br>
<h3>21:16</h3>
图的广度搜索（BFS）用队列实现，而深度搜索（DFS）用递归实现。<br>
dinic算法中的构造层次结构时用的是BFS，而寻找每个增广路径上的最小流量时用的是DFS。<br>
<h2>16年5月23</h2>
<h3>下午3:24</h3>
预流推进方法（preflow-push-method）<br>
这是最大流问题中效率最高的方法<br>
预流推进最大流的步骤：<br>
数据格式说明：顶点数n，邻接矩阵（存储每个边的容量）table[n][n]，存储顶点层数的数组level[n]，活动顶点集合Q，每个顶点的盈余流量R[n]<br>
level存储的是顶点距离汇点t的距离（层数）<br>
1.初始化邻接矩阵为容量（反向弧容量设置为0）,初始化level数组为0，但源顶点的level[s]为n。<br>
2.把源顶点压入到Q中。<br>
3.while !Q.empty()<br>
&nbsp;u=Q.front();<br>
&nbsp;Q.pop();<br>
&nbsp;当u为源顶点或者在顶点中存在比u的level少1的顶点v时:<br>
&nbsp;&nbsp;向v推进最大流（c(u,v)）；（u点的R值减少c(u,v)，v点的R值增加c(u,v)）<br>
&nbsp;&nbsp;如果推进之前的R[u]<c(u,v)，则推进的流值为R[u]<br>
&nbsp;&nbsp;响应的反向弧值增加，正向弧值减少（c(u,v)减少推进流值，c(v,u)增加推进的流值）<br>
&nbsp;&nbsp;如果v点是汇点t，则全局的最大流量值（所求的结果）+=推进的流量值<br>
&nbsp;&nbsp;如果v不是源顶点s也不是汇点t，则Q.push(v)<br>
&nbsp;如果u不是s也不是t而且R[u]还有残余量：<br>
&nbsp;&nbsp;把u的level加1，压入到Q中。<br>
  end while<br>
4.结束。<br>
