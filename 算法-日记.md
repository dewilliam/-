<h2>16年5月24</h2>
<h3>下午3点22</h3>
今天开始复习基础的算法<br>
算法主要是学习算法的思想，思想可以用到很多问题的解决思路上，不要局限与代码的实现。<br>
具体代码的实现要结合不同的数据结构来做。<br>
<h2>贪心算法</h2>
贪心算法是不能联机处理数据的，这样算法不知道数据的整体情况，得不到最优解！！<br>
<br>
贪心算法在应用前要先证明整体最优解是有局部最优解而的来，否则，算法得不到问题的最优解。<br>
但是贪心算法比较简单，编程也简单。。。<br>
寻找图的单源最短路径（dijkstra算法等）和最小生成树（prime算法等）都是用的贪心思想<br>
<br>
要看问题是否能用贪心算法解决，是要看该问题是否有贪心选择性质和最优子结构性质：<br>
贪心选择性质是说整个问题的最优解是可以用几个局部最优解得到。贪心是自顶向下解决问题（动态规划是自底向上）。<br>
&emsp;&emsp;每进行一次贪心选择，就把问题变为更小的子问题解决。<br>
最优子结构性质是说，整体问题的最优解是可以推导出子问题的局部最优解的。<br>
<br>
所以说贪心算法能解决背包问题，但是不能解决0-1背包问题（区别就是：背包问题是可以装入某件物品的一部分，而0-1不能）<br>
<br>
解释一下为什么0-1背包问题不满足贪心选择性质：<br>
&emsp;&emsp;因为该问题的局部最优解不能导致整体的最优解（这是废话哈，跟不满足性质是一个意思。。。）<br>
&emsp;&emsp;当每一步选择当前局部最优解的解决方案时，并不能保证背包是会被装满的<br>
&emsp;&emsp;如果不能被装满的话，最后的背包的单位空间内负载的价值就不是最优的。<br>
&emsp;&emsp;也就是说，这一步的最优解和下一步的最优解可能是冲突的，（这一步的非最优解可能导致下一步的最优解）<br>
&emsp;&emsp;这就不满足贪心选择性质和最优子结构性质。。。<br>
<br>
<h3>贪心算法的几种情况：</h3>
1.活动时间排序问题。<br>
&emsp;&emsp;有n个活动，每个活动有自己的开始时间start[n]和结束时间finish[n]。这些活动都要共用一个场地（资源）<br>
那么怎么安排才能使这些活动中举行的活动数量最多。<br>
这时就用贪心算法，首先要把活动按照结束时间排序（非递减），每次选择结束时间最早，但又不与已经计划的活动时间冲突的活动<br>
这样算法，安排活动时间复杂度为O(n)，排序要花O(nlog(n))<br>
<br>
2.哈夫曼编码问题。<br>
&emsp;&emsp;对文件的压缩处理。<br>
&emsp;&emsp;根据文件中某个字符（单词）的出现次数进行0-1字符串编码，出现次数少的码长要较长，多的要较少。<br>
&emsp;&emsp;背景如上所述。。。<br>
&emsp;&emsp;哈夫曼编码的解决方案是：把每个字符（单词）构成一棵树，这样一个文档就生成了一个森林。<br>
每次选取出现次数最少的两棵树合并成一棵树，，这颗树的次数是两颗子树的次数之和。每次都这样做，知道森林中只有一棵树<br>
平均码长的定义为：Σ(f*l)，f是字符（单词）的出现频率，l是编码码长。<br>
哈夫曼编码得到的平均码长是最短的，即为最优解<br>
<br>
我只能感性的感觉哈夫曼编码是满足贪心选择和最优子结构性质的，具体怎么证明。。还有待查资料。。。<br>
<br>
3.图的单源最短路径和最小生成树。<br>
&emsp;&emsp;见《图-日记.md》<br>
<br>
<br>
<h3>晚上22:00</h3>
晚上处理了一些小问题，继续搞算法。。<br>
<h3>分治算法</h3>
分治算法的核心思想是把大问题分解成小问题，这样容易解决，解决之后在合并为整体问题的解。<br>
能用分治算法解决的问题的特征是：<br>
&emsp;&emsp;大问题能分解成小问题，大问题的最优解能推到出小问题的最优解（即有最优子结构）。<br>
&emsp;&emsp;各个小问题之间是相互独立的，互不影响。<br>
&emsp;&emsp;各个小问题中没有重叠的子问题。（这点是与动态规划的区别。。。）<br>
&emsp;&emsp;而且当问题缩小到一定规模之后能很容易的解决。<br>
分治算法与贪心算法的区别：<br>
&emsp;&emsp;贪心是一步一步的搭建最优解，而分治算法是每次解决一个最小问题的最优解，最后合并成大问题最优解。<br>
&emsp;&emsp;贪心过程中，如果有一点没有达到局部最优解，则以后的过程全不是最优解。而分治中，某个小问题不是最优解，其他的部分也可以是最优解。<br>
