<h2>16年5月24</h2>
<h3>下午3点22</h3>
今天开始复习基础的算法<br>
算法主要是学习算法的思想，思想可以用到很多问题的解决思路上，不要局限与代码的实现。<br>
具体代码的实现要结合不同的数据结构来做。<br>
<h2>贪心算法</h2>
贪心算法是不能联机处理数据的，这样算法不知道数据的整体情况，得不到最优解！！<br>
<br>
贪心算法在应用前要先证明整体最优解是有局部最优解而的来，否则，算法得不到问题的最优解。<br>
但是贪心算法比较简单，编程也简单。。。<br>
寻找图的单源最短路径（dijkstra算法等）和最小生成树（prime算法等）都是用的贪心思想<br>
<br>
要看问题是否能用贪心算法解决，是要看该问题是否有贪心选择性质和最优子结构性质：<br>
贪心选择性质是说整个问题的最优解是可以用几个局部最优解得到。贪心是自顶向下解决问题（动态规划是自底向上）。<br>
&emsp;&emsp;每进行一次贪心选择，就把问题变为更小的子问题解决。<br>
最优子结构性质是说，整体问题的最优解是可以推导出子问题的局部最优解的。<br>
<br>
所以说贪心算法能解决背包问题，但是不能解决0-1背包问题（区别就是：背包问题是可以装入某件物品的一部分，而0-1不能）<br>
<br>
解释一下为什么0-1背包问题不满足贪心选择性质：<br>
&emsp;&emsp;因为该问题的局部最优解不能导致整体的最优解（这是废话哈，跟不满足性质是一个意思。。。）<br>
&emsp;&emsp;当每一步选择当前局部最优解的解决方案时，并不能保证背包是会被装满的<br>
&emsp;&emsp;如果不能被装满的话，最后的背包的单位空间内负载的价值就不是最优的。<br>
&emsp;&emsp;也就是说，这一步的最优解和下一步的最优解可能是冲突的，（这一步的非最优解可能导致下一步的最优解）<br>
&emsp;&emsp;这就不满足贪心选择性质和最优子结构性质。。。<br>
<br>
<h3>贪心算法的几种情况：</h3>
1.活动时间排序问题。<br>
&emsp;&emsp;有n个活动，每个活动有自己的开始时间start[n]和结束时间finish[n]。这些活动都要共用一个场地（资源）<br>
那么怎么安排才能使这些活动中举行的活动数量最多。<br>
这时就用贪心算法，首先要把活动按照结束时间排序（非递减），每次选择结束时间最早，但又不与已经计划的活动时间冲突的活动<br>
这样算法，安排活动时间复杂度为O(n)，排序要花O(nlog(n))<br>
<br>
2.哈夫曼编码问题。<br>
&emsp;&emsp;对文件的压缩处理。<br>
&emsp;&emsp;根据文件中某个字符（单词）的出现次数进行0-1字符串编码，出现次数少的码长要较长，多的要较少。<br>
&emsp;&emsp;背景如上所述。。。<br>
&emsp;&emsp;哈夫曼编码的解决方案是：把每个字符（单词）构成一棵树，这样一个文档就生成了一个森林。<br>
每次选取出现次数最少的两棵树合并成一棵树，，这颗树的次数是两颗子树的次数之和。每次都这样做，知道森林中只有一棵树<br>
平均码长的定义为：Σ(f*l)，f是字符（单词）的出现频率，l是编码码长。<br>
哈夫曼编码得到的平均码长是最短的，即为最优解<br>
<br>
我只能感性的感觉哈夫曼编码是满足贪心选择和最优子结构性质的，具体怎么证明。。还有待查资料。。。<br>
<br>
3.图的单源最短路径和最小生成树。<br>
&emsp;&emsp;见《图-日记.md》<br>
<br>
<br>
<h3>晚上22:00</h3>
晚上处理了一些小问题，继续搞算法。。<br>
<h3>分治算法</h3>
分治算法的核心思想是把大问题分解成小问题，这样容易解决，解决之后在合并为整体问题的解。<br>
能用分治算法解决的问题的特征是：<br>
&emsp;&emsp;大问题能分解成小问题，大问题的最优解能推到出小问题的最优解（即有最优子结构）。<br>
&emsp;&emsp;各个小问题之间是相互独立的，互不影响。<br>
&emsp;&emsp;各个小问题中没有重叠的子问题。（这点是与动态规划的区别。。。）<br>
&emsp;&emsp;而且当问题缩小到一定规模之后能很容易的解决。<br>
分治算法与贪心算法的区别：<br>
&emsp;&emsp;贪心是一步一步的搭建最优解，而分治算法是每次解决一个最小问题的最优解，最后合并成大问题最优解。<br>
&emsp;&emsp;贪心过程中，如果有一点没有达到局部最优解，则以后的过程全不是最优解。而分治中，某个小问题不是最优解，其他的部分也可以是最优解。<br>
<br>
用分治解决问题的步骤：<br>
主要是数学归纳法找到问题的求解方程。<br>
1.找到最小规模的问题，并找到解决方法。<br>
2.找到小问题合并成大问题的方法。<br>
3.设计递归过程。<br>
<br>
<br>
<br>
插入一个另外的东西，虽然分治算法可以有效的在O(nlog(n))时间内解决最大连续子数组和的问题。<br>
但是该问题还有更好的解决方法，可以在O(N)的时间内解决掉。<br>
当已经有了前（i-1）个数的最大连续子数组和时，扫描到第i个数后，要么包括i点，要么只有i点，要么就还是原来的子数组。<br>
so，设置两个变量：max_here，max_so_far。<br>
&emsp;&emsp;max_here保存的是前两种情况的最大值（包括i点，只有i点）。这样设置是为了在循环时max_here中保存的值对应的数组都是连续的，不会出现中间有间隔的情况。。。<br>
&emsp;&emsp;max_so_far保存的是迄今为止的整体最大连续子数组和，每次循环时，改变量都与max_here比较，保存最大值。<br>
&emsp;&emsp;两个变量的初始化：若数组中有非负数，则初始化为0；若全是负数，则初始化为数组中的最小值。<br>
这样循环一趟数组就可以得出结果了。。。<br>
<br>
然后求数组逆序对问题：快速排序中进行多少次的元素交换，就有多少个的逆序对。所以过程和快排一样，只是多加了一步统计而已。<br>
用分治法求解大数相乘问题，简直就是折腾字符串啊，，太折腾了。。。<br>
写了一个超级简单的demo，就不传到github上了。。。~>_<~...<br>
<br>
<h2>16年5月25</h2>
<h3>下午5:20</h3>
<h3>动态规划</h3>
开始折腾动态规划了。。。<br>
动态规划是自底向上的求解问题，把每一个小问题的解都存储起来，当上面调用的时候，直接调用结果就好，就不用再去求解一遍小问题了，这样有效的改进了递归程序中的多余的运算。。。<br>
很多情况下，递归方法肯定不是最好的。。。<br>
